### 1

ĞŸĞ¾ÑÑ‡Ğ¸Ñ‚Ğ°Ğ¹Ñ‚Ğµ ÑÑƒĞ¼Ğ¼Ñƒ n-Ğ³Ğ¾ Ñ€ÑĞ´Ğ° Ğ¿Ğ¸Ñ€Ğ°Ğ¼Ğ¸Ğ´Ñ‹ Ğ½ĞµÑ‡ĞµÑ‚Ğ½Ñ‹Ñ… Ñ‡Ğ¸ÑĞµĞ» (Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ñ 1)

Â  Â  Â  1

Â  Â  Â 3 5

Â  Â  7 9 11

Â  13 15 17 19

Â 21 23 25 27 29

  

ĞÑ‚Ğ²ĞµÑ‚:

  

```go

func Sum(pir [][]int, n int) int {

Â  Â  sum := 0

Â  Â  for i := 0; i <= n; i++ {

Â  Â  Â  Â  sum += pir[n][i]

Â  Â  }

Â  Â  return sum

}


fmt.Println(Sum([][]int{{1}, {3, 5}, {7, 9, 11}}, 2))

```

  

---

  

### 2

Ğ ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞ¹Ñ‚Ğµ Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ¼Ğ°ÑÑĞ¸Ğ² Ğ¸ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰Ğ°ĞµÑ‚ Ğ²ÑĞµ Ğ½ÑƒĞ»Ğ¸ Ğ² ĞºĞ¾Ğ½ĞµÑ†, ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑÑ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ².

[1, 0, 1, 2, 0, 1, 3]

ĞÑ‚Ğ²ĞµÑ‚:

```go

// Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚ 1

func moveZeros(arr []int) []int {

Â  Â  // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¼Ğ°ÑÑĞ¸Ğ² Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°

Â  Â  result := make([]int, 0, len(arr))

Â  Â  zeroCount := 0

  

Â  Â  // ĞŸÑ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ¾ Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ğ¼Ğ°ÑÑĞ¸Ğ²Ñƒ

Â  Â  for _, num := range arr {

Â  Â  Â  Â  if num != 0 {

Â  Â  Â  Â  Â  Â  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½ĞµĞ½ÑƒĞ»ĞµĞ²Ñ‹Ğµ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹ Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚

Â  Â  Â  Â  Â  Â  result = append(result, num)

Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  // Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº Ğ½ÑƒĞ»ĞµĞ¹

Â  Â  Â  Â  Â  Â  zeroCount++

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½ÑƒĞ»Ğ¸ Ğ² ĞºĞ¾Ğ½ĞµÑ† Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°

Â  Â  for i := 0; i < zeroCount; i++ {

Â  Â  Â  Â  result = append(result, 0)

Â  Â  }

  

Â  Â  return result

}

arr := []int{1, 0, 1, 2, 0, 1, 3}

result := moveZeros(arr)

fmt.Println(result) // Ğ’Ñ‹Ğ²Ğ¾Ğ´: [1 1 2 1 3 0 0]

  

// Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚ 2

  

func moveZeros(arr []int) {

Â  Â  // Ğ˜Ğ½Ğ´ĞµĞºÑ Ğ´Ğ»Ñ Ğ½ĞµĞ½ÑƒĞ»ĞµĞ²Ñ‹Ñ… ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²

Â  Â  lastNonZeroIndex := 0

  

Â  Â  // ĞŸÑ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ¾ Ğ¼Ğ°ÑÑĞ¸Ğ²Ñƒ

Â  Â  for i := 0; i < len(arr); i++ {

Â  Â  Â  Â  if arr[i] != 0 {

Â  Â  Â  Â  Â  Â  // ĞœĞµĞ½ÑĞµĞ¼ Ğ¼ĞµÑÑ‚Ğ°Ğ¼Ğ¸ Ğ½ĞµĞ½ÑƒĞ»ĞµĞ²Ğ¾Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ Ñ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ¼ Ğ½Ğ° Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ lastNonZeroIndex

Â  Â  Â  Â  Â  Â  arr[lastNonZeroIndex], arr[i] = arr[i], arr[lastNonZeroIndex]

Â  Â  Â  Â  Â  Â  lastNonZeroIndex++

Â  Â  Â  Â  }

Â  Â  }

}

arr := []int{1, 0, 1, 2, 0, 1, 3}

moveZeros(arr)

fmt.Println(arr) // Ğ’Ñ‹Ğ²Ğ¾Ğ´: [1 1 2 1 3 0 0]

```

  

---

  

### 3

  

Ğ’Ñ‹Ğ²ĞµÑÑ‚Ğ¸ Ğ´Ğ»Ğ¸Ğ½Ñƒ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ² ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°Ñ… Ğ¸ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ±Ğ°Ğ¹Ñ‚

"Ğ§Ñ‚Ğ¾ Ñ‚Ğ¾ world %$@@&"

  

ĞÑ‚Ğ²ĞµÑ‚

  

```go

// Ğ”Ğ»Ğ¸Ğ½Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ² ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°Ñ…

lengthInRunes := utf8.RuneCountInString(str)

// ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ±Ğ°Ğ¹Ñ‚

byteCount := len(str)

  

fmt.Printf("Ğ”Ğ»Ğ¸Ğ½Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ² ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°Ñ…: %dn", lengthInRunes)

fmt.Printf("ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ±Ğ°Ğ¹Ñ‚: %dn", byteCount)

```

  

---
### 4

  

Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ

"Hello, world!"

Ğ’ÑĞµ l Ğ½Ğ° n

  

ĞÑ‚Ğ²ĞµÑ‚

  

```go

str := "Hello, world!"

Â // Ğ—Ğ°Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ²ÑĞµ 'l' Ğ½Ğ° 'n'

Â newStr := strings.ReplaceAll(str, "l", "n")

  

Â fmt.Println(newStr) // Ğ’Ñ‹Ğ²Ğ¾Ğ´: "Henno, worrd!"

```

  

---

  

### 5

  

Ğ¡Ğ»Ğ¸Ñ‚ÑŒ N ĞºĞ°Ğ½Ğ°Ğ»Ğ¾Ğ² Ğ² Ğ¾Ğ´Ğ¸Ğ½

  

```go

func merge(chs ...chan int) chan int {

}

  

func main() {

Â  Â  ch1 := startProducerA()

Â  Â  ch2 := startProducerB()

  

Â  Â  for el := range merge(ch1, ch2) {

Â  Â  Â  Â  println(el)

Â  Â  }

}

```

ĞÑ‚Ğ²ĞµÑ‚

  

```go

func merge(chs ...chan int) chan int {

Â  Â  newCh := make(chan int)

Â  Â  wg := sync.WaitGroup{}

  

Â  Â  for _, ch := range chs {

Â  Â  Â  Â  wg.Add(1)

Â  Â  Â  Â  go func(ch chan int) {

Â  Â  Â  Â  Â  Â  for val := range ch {

Â  Â  Â  Â  Â  Â  Â  Â  newCh <- val

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  wg.Done()

Â  Â  Â  Â  }(ch)

Â  Â  }

  

Â  Â  go func() {

Â  Â  Â  Â  wg.Wait()

Â  Â  Â  Â  close(newCh)

Â  Â  }()

  

Â  Â  return newCh

}

```

  

---

  

### 6

  

ĞŸĞ¾Ğ½ÑÑ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ¸ Ñ€ĞµĞ²Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ

```

[1,2,3,4,5] -> [1,3,5]

[2,2,2] -> []

[1,2,2] -> [1]

```

  

ĞÑ‚Ğ²ĞµÑ‚

  

```go

func filter(a []int) []int {

Â  Â  var n int

  

Â  Â  for i := 0; i < len(a); i++ {

Â  Â  Â  Â  if a[i]%2 != 0 {

Â  Â  Â  Â  Â  Â  a[n] = a[i]

Â  Â  Â  Â  Â  Â  n++

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  return a[:n]

}

```

  

---

  

### 7

  

ĞŸÑ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚ rate limiter ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑƒ Limiter

ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ¾Ğ½Ñ†ĞµĞ¿Ñ‚ Ğ·Ğ°ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ÑÑ Ğ² Ñ‚Ğ¾Ğ¼, Ñ‡Ñ‚Ğ¾ Ñƒ Ğ½Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ğ°Ñ ĞºĞ¾Ñ€Ğ·Ğ¸Ğ½Ğ° Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ ĞºĞ»ÑÑ‡Ğ° key, Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğµ

Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° Allow Ğ¼Ñ‹ ÑƒĞ¼ĞµĞ½ÑŒÑˆĞ°ĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² Ğ½Ğ° 1.

Ğ•ÑĞ»Ğ¸ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² ÑÑ‚Ğ°Ğ»Ğ¾ Ñ€Ğ°Ğ²Ğ½Ñ‹Ğ¼ 0, Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ false, Ğ² Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ»ÑƒÑ‡Ğ°ÑÑ… Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ true .

Ğ¢Ğ¾ĞºĞµĞ½Ñ‹ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ÑÑÑ‚ÑÑ Ñ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒÑ, ÑĞºĞ°Ğ¶ĞµĞ¼ n Ğ² ÑĞµĞº Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ ĞºĞ»ÑÑ‡Ğ°. Ğ¢Ğ°ĞºĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ

Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ², Ğ²Ñ‹ÑˆĞµ ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ³Ğ¾ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ Ğ½Ğµ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ÑÑÑ‚ÑÑ.

  

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€, Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² Ğ´Ğ»Ñ ĞºĞ»ÑÑ‡Ğ° 5, Ğ·Ğ° ĞºĞ°Ğ¶Ğ´ÑƒÑ ÑĞµĞºÑƒĞ½Ğ´Ñƒ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ÑĞµÑ‚ÑÑ 5 Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ², Ğ·Ğ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ

ÑĞ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµÑ‚ÑÑ 1 Ñ‚Ğ¾ĞºĞµĞ½.

Ğ­Ñ‚Ğ¾ Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚, Ñ‡Ñ‚Ğ¾ Ğ¼Ñ‹ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ 5 Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ² ÑĞµĞºÑƒĞ½Ğ´Ñƒ.

  

ĞœĞ½Ğ¾Ğ³Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡ĞºÑƒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ´ÑƒĞ¼Ğ°Ñ‚ÑŒ

Ğ“Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñ‹ Ğ·Ğ´ĞµÑÑŒ Ğ½Ğµ Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±ÑƒÑÑ‚ÑÑ

ĞœÑ‹ Ğ¼Ğ¾Ğ¶ĞµĞ¼ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ²Ñ€ĞµĞ¼Ñ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ³Ğ¾ Ğ·Ğ°Ñ…Ğ¾Ğ´Ğ° Ğ² Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¿Ğ¾ ĞºĞ»ÑÑ‡Ñƒ Ğ¸ Ğ¿Ñ€Ğ¸ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğµ Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ÑÑ‚ÑŒ Ğ´ĞµĞ»ÑŒÑ‚Ñƒ Ğ¼ĞµĞ¶Ğ´Ñƒ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¼

Ğ²Ñ€ĞµĞ¼ĞµĞ½ĞµĞ¼ Ğ¸ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ğ¼. Ğ˜ÑÑ…Ğ¾Ğ´Ñ Ğ¸Ğ· ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ÑÑ‚ÑŒ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹

Ğ•Ğ´Ğ¸Ğ½Ğ¸Ñ†Ğ° Ğ¾ĞºÑ€ÑƒĞ³Ğ»ĞµĞ½Ğ¸Ñ, ĞµĞ´Ğ¸Ğ½Ğ¸Ñ†Ğ° Ñ€Ğ°ÑÑ‡ĞµÑ‚Ğ° ÑĞµĞºÑƒĞ½Ğ´Ñ‹. Ğ•ÑĞ»Ğ¸ Ğ´ĞµĞ»ÑŒÑ‚Ğ° 0ÑĞµĞº, Ñ‚Ğ¾ Ğ½Ñ‡Ğ¸ĞµĞ³Ğ¾ Ğ½Ğµ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼.

  

```go

type Limiter interface {

Â  Â  Allow(key string) bool

}

```

  

ĞÑ‚Ğ²ĞµÑ‚

  

```go

type Limiter interface {

Â  Â  Allow(key string) bool

}

  

type tokenParams struct { // ĞŸÑ€Ğ¾ Ğ¼Ğ½Ğ¾Ğ³Ğ¾Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡ĞºÑƒ: Ñ…Ğ¾Ñ‡ĞµÑ‚ÑÑ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¼ÑŒÑÑ‚ĞµĞºÑğŸ˜

Â  Â  max Â  Â  Â  Â int32

Â  Â  speed Â  Â  Â int32

Â  Â  count Â  Â  Â int32

Â  Â  accessTime time.Time

}

  

type Baskets struct {

Â  Â  basket map[string]tokenParams

}

  

func NewBaskets() Baskets {

Â  Â  baskets := Baskets{

Â  Â  Â  Â  basket: make(map[string]tokenParams),

Â  Â  }

  

Â  Â  return baskets

}

  

func (b Baskets) Allow(key string) bool {

Â  Â  if _, exists := b.basket[key]; !exists {

Â  Â  Â  Â  fmt.Printf("key %s not found", key)

Â  Â  Â  Â  return false

Â  Â  }

  

Â  Â  creditedTokens := int32(0)

Â  Â  now := time.Now()

  

Â  Â  if !b.basket[key].accessTime.IsZero() {

Â  Â  Â  Â  delta := now.Sub(b.basket[key].accessTime).Seconds()

Â  Â  Â  Â  creditedTokens = int32(math.Floor(delta)) * b.basket[key].speed // Ğ·Ğ° < 1 ÑĞµĞºÑƒĞ½Ğ´Ñ‹ Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ÑĞµÑ‚ÑÑ 0

  

Â  Â  Â  Â  if creditedTokens > b.basket[key].max {

Â  Â  Â  Â  Â  Â  creditedTokens = b.basket[key].max

Â  Â  Â  Â  }

Â  Â  } else {

Â  Â  Â  Â  creditedTokens = b.basket[key].max // Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ñ€Ğ°Ğ· Ğ½Ğ°Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼

Â  Â  }

  

Â  Â  newCount := b.basket[key].count - 1 + creditedTokens

Â  Â  if newCount < 0 { // Ğ½Ğµ ÑĞ½Ğ¸Ğ¶Ğ°ĞµĞ¼ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹, ĞµÑĞ»Ğ¸ Ñ‚Ğ¾ĞºĞµĞ½Ñ‹ Ğ¿Ğ¾Ñ‚Ñ€Ğ°Ñ‡ĞµĞ½Ñ‹

Â  Â  Â  Â  return false

Â  Â  }

  

Â  Â  b.basket[key] = tokenParams{

Â  Â  Â  Â  max: Â  Â  Â  Â b.basket[key].max,

Â  Â  Â  Â  speed: Â  Â  Â b.basket[key].speed,

Â  Â  Â  Â  count: Â  Â  Â newCount,

Â  Â  Â  Â  accessTime: now,

Â  Â  }

  

Â  Â  return true

}

  

basket := NewBaskets()

basket.basket["key"] = tokenParams{

Â  Â  max: Â  Â  Â  Â 5,

Â  Â  speed: Â  Â  Â 1,

Â  Â  count: Â  Â  Â 5,

Â  Â  accessTime: time.Time{},

}

fmt.Println(basket.Allow("key"))

fmt.Println(basket.Allow("key"))

fmt.Println(basket.Allow("key"))

fmt.Println(basket.Allow("key"))

fmt.Println(basket.Allow("key"))

```

  

---

  

### 8

  

ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²ĞµÑÑ‚Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ÑÑÑ‹Ğ»Ğ¾Ğº, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ² GET Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ½Ğ° URL Ğ¸ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ 200 ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° Ğ¸Ğ»Ğ¸ Ğ¸Ğ½Ğ¾Ğ¹

Ğ Ğ°ÑĞ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ÑÑÑ‹Ğ»Ğ¾Ğº

Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¸Ğ·Ğ²Ğ½Ğµ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ° Ğ¾ Ğ¿Ñ€ĞµĞºÑ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğ¸ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹

```go

func main() {

Â  Â  var urls = []string{

Â  Â  Â  Â  "http://google.com",

Â  Â  Â  Â  "https://ya.ru",

Â  Â  Â  Â  "http://ya.ru",

Â  Â  }

}

  

func getExternalSignal() chan struct{} {

Â  Â  return make(chan struct{})

}

```

  

ĞÑ‚Ğ²ĞµÑ‚

  

```go

func main() {

Â  Â  var urls = []string{

Â  Â  Â  Â  "http://google.com",

Â  Â  Â  Â  "https://ya.ru",

Â  Â  Â  Â  "http://ya.ru",

Â  Â  }

  

Â  Â  externalSignal := getExternalSignal()

Â  Â  sign := atomic.Int32{}

Â  Â  go func() {

Â  Â  Â  Â  <-externalSignal

Â  Â  Â  Â  sign.Store(1)

Â  Â  }()

Â  Â  ch := make(chan string)

Â  Â  wg := sync.WaitGroup{}

  

Â  Â  wg.Add(len(urls))

Â  Â  for i := 0; i < len(urls); i++ {

Â  Â  Â  Â  i := i

Â  Â  Â  Â  go func() {

Â  Â  Â  Â  Â  Â  if sign.Load() == 1 {

Â  Â  Â  Â  Â  Â  Â  Â  return

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  resp, err := http.Get(urls[i])

Â  Â  Â  Â  Â  Â  if err != nil {

Â  Â  Â  Â  Â  Â  Â  Â  slog.Error("err", "http get", err)

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  if resp.StatusCode == 200 {

Â  Â  Â  Â  Â  Â  Â  Â  ch <- fmt.Sprintf("Ğ°Ğ´Ñ€ĞµÑ %s - ok", urls[i])

Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  ch <- "not ok"

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  Â  Â  wg.Done()

Â  Â  Â  Â  }()

Â  Â  }

  

Â  Â  go func() {

Â  Â  Â  Â  wg.Wait()

Â  Â  Â  Â  close(ch)

Â  Â  }()

  

Â  Â  for msg := range ch {

Â  Â  Â  Â  fmt.Println(msg)

Â  Â  }

}

  

func getExternalSignal() chan struct{} {

Â  Â  return make(chan struct{})

}

```

  

---

  

Ğ”Ğ°Ğ½ Ğ¼Ğ°ÑÑĞ¸Ğ² meetings, Ğ² ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ¼ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚ meeting[i] - ÑÑ‚Ğ¾ Ğ¿Ğ°Ñ€Ğ° Ğ´Ğ²ÑƒÑ… Ñ‡Ğ¸ÑĞµĞ» [startTime, endTime].

ĞĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ Ğ¾Ğ±ÑŠĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ½Ğ°ĞºĞ»Ğ°Ğ´Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸ĞµÑÑ Ğ´Ñ€ÑƒĞ³ Ğ½Ğ° Ğ´Ñ€ÑƒĞ³Ğ° Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ¸ Ğ¸ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¼Ğ°ÑÑĞ¸Ğ² Ñ Ğ¾Ğ±ÑŠĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ°Ğ¼Ğ¸, Ğ¿Ğ¾ĞºÑ€Ñ‹Ğ²Ğ°ÑÑ‰Ğ¸Ñ… Ñ‚Ğµ Ğ¶Ğµ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ»Ğ¾Ñ‚Ñ‹.

  

Input: [[1,3], [2,6], [8,10], [15,18]]

Output: [[1,6], [8,10], [15,18]]

Explanation: Ğ˜Ğ½Ñ‚ĞµÑ€Ğ²Ğ°Ğ»Ñ‹ [1,3] Ğ¸ [2,6] Ğ¿ĞµÑ€ĞµÑĞµĞºĞ°ÑÑ‚ÑÑ => Ğ¾Ğ±ÑŠĞµĞ´Ğ¸Ğ½ÑĞµĞ¼ Ğ² [1,6].

  

```go

func join(meet [][]int) [][]int{

Â  Â  intervals := make([][]int, 0)

  

Â  Â  for i := 0; i < len(meet) - 1; i++{

Â  Â  Â  Â  if meet[i][1] > meet[i+1][0]{

Â  Â  Â  Â  Â  Â  intervals = append(intervals, []int{meet[i][0], meet[i+1][1]})

Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  intervals = append(intervals, meet[i])

Â  Â  Â  Â  }

Â  Â  }

  

Â  Â  return intervals

}

```

  

---

  

### 9

  

Ğ’Ñ‹Ğ²ĞµÑÑ‚Ğ¸ Ñ‡Ğ¸ÑĞ»Ğ° Ğ¾Ñ‚ 1 Ğ´Ğ¾ 10 Ñ„ÑƒĞ½ĞºÑ†Ğ¸ĞµĞ¹ Ñ PrintLn Ğ¸ Ğ·Ğ°Ğ´ĞµĞ¶ĞºĞ¾Ğ¹ 1 ÑĞµĞºÑƒĞ½Ğ´Ğ° Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¾Ğ¼ Ğ¿Ğ¾ 5 Ñ‡Ğ¸ÑĞµĞ» Ğ² Ğ¾Ğ´Ğ½Ğ¾Ğ¼ Ğ¿Ğ¾Ñ‚Ğ¾ĞºĞµ

  

```go

func printNumbers() {

Â for i := 1; i <= 10; i++ {

Â  fmt.Println(i)

Â  if i%5 == 0 {

Â  Â time.Sleep(1 * time.Second) // Ğ—Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ² 1 ÑĞµĞºÑƒĞ½Ğ´Ñƒ Ğ¿Ğ¾ÑĞ»Ğµ ĞºĞ°Ğ¶Ğ´Ñ‹Ñ… 5 Ñ‡Ğ¸ÑĞµĞ»

Â  }

Â }

}

```

  

---

  

### 10

  

Ğ§Ñ‚Ğ¾ Ğ²Ñ‹Ğ²ĞµĞ´ĞµÑ‚ ĞºĞ¾Ğ´ Ğ¸ Ğ¿Ğ¾Ñ‡ĞµĞ¼Ñƒ?

  

```go

func setLinkHome(link *string) {

Â  Â  *link = "http://home"

}

  

func main() {

Â  Â  link := "http://other"

  

Â  Â  setLinkHome(&link)

  

Â  Â  fmt.Println(link)

}

```

  

---

  

### 11

  

Ğ‘ÑƒĞ´ĞµÑ‚ Ğ»Ğ¸ Ğ½Ğ°Ğ¿ĞµÑ‡Ğ°Ñ‚Ğ°Ğ½ â€œokâ€ ?

  

```go

func main() {

Â  Â  defer func() {

Â  Â  Â  Â  recover()

Â  Â  }()

  

Â  Â  panic("test panic")

  

Â  Â  fmt.Println("ok")

}

```

  

---

  

### 12

  

Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ½Ğ°Ğ¿ĞµÑ‡Ğ°Ñ‚Ğ°Ñ‚ÑŒ:

one

two

three

(Ğ² Ğ»ÑĞ±Ğ¾Ğ¼ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞµ Ğ¸ Ğ² ĞºĞ¾Ğ½Ñ†Ğµ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾)

done!

  

ĞĞ¾ ÑÑ‚Ğ¾ Ğ½Ğµ Ñ‚Ğ°Ğº, Ğ¸ÑĞ¿Ñ€Ğ°Ğ²ÑŒ ĞºĞ¾Ğ´

  

```go

func printText(data []string) {

Â  Â  for _, v := range data {

Â  Â  Â  Â  go func() {

Â  Â  Â  Â  Â  Â  fmt.Println(v)

Â  Â  Â  Â  }()

  

Â  Â  }

  

Â  Â  fmt.Println("done!")

  

}

  

func main() {

Â  Â  data := []string{"one", "two", "three"}

  

Â  Â  printText(data)

}

```

  

---

  

### 13

  

ĞœÑ‹ Ğ¿Ñ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ¿Ğ¾Ğ´ÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ¾ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹, Ñ‡Ñ‚Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ğ¾Ğ¹Ñ‚Ğ¸ Ğ½Ğµ Ñ‚Ğ°Ğº?

  

```go

var callCounter uint

  

func main() {

Â  Â  wg := sync.WaitGroup{}

  

Â  Â  wg.Add(10000)

Â  Â  for i := 0; i < 10000; i++ {

Â  Â  Â  Â  go func() {

Â  Â  Â  Â  Â  Â  // Ğ¥Ğ¾Ğ´Ğ¸Ğ¼ Ğ² Ğ±Ğ°Ğ·Ñƒ, Ğ´ĞµĞ»Ğ°ĞµĞ¼ Ğ´Ğ¾Ğ»Ğ³ÑƒÑ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ

Â  Â  Â  Â  Â  Â  time.Sleep(time.Second)

Â  Â  Â  Â  Â  Â  // Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº

Â  Â  Â  Â  Â  Â  callCounter++

Â  Â  Â  Â  Â  Â  wg.Done()

Â  Â  Â  Â  }()

Â  Â  }

  

Â  Â  wg.Wait()

  

Â  Â  fmt.Println("Call counter value = ", callCounter)

}

```

  

---

  

### 14

  

Ğ•ÑÑ‚ÑŒ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ processDataInternal, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ°Ñ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑ‚ÑŒÑÑ Ğ½ĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ½Ğ¾ Ğ´Ğ¾Ğ»Ğ³Ğ¾.

Ğ§Ñ‚Ğ¾Ğ±Ñ‹ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ, Ğ¼Ñ‹ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ğ»Ğ¸ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ñ„-Ğ¸Ğ¸ Ñ‡ĞµÑ€ĞµĞ· context.

ĞšĞ°ĞºĞ¸Ğµ Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚ĞºĞ¸ ĞºĞ¾Ğ´Ğ° Ğ½Ğ¸Ğ¶Ğµ?

  

```go

type Service struct {

}

  

func (s *Service) processDataInternal(r io.Reader) error {

Â  Â  return nil

}

  

func (s *Service) ProcessData(timeoutCtx context.Context, r io.Reader) error {

Â  Â  errCh := make(chan error)

  

Â  Â  go func() {

Â  Â  Â  Â  errCh <- s.processDataInternal(r)

Â  Â  }()

  

Â  Â  select {

Â  Â  case err := <-errCh:

Â  Â  Â  Â  return err

Â  Â  case <-timeoutCtx.Done():

Â  Â  Â  Â  return timeoutCtx.Err()

Â  Â  }

}

```

  

---

  

### 15

  

ĞĞ¿Ğ¸ÑˆĞ¸, Ñ‡Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°ĞµÑ‚ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ isCallAllowed?

  

```go

var callCount = make(map[uint]uint)

  

var locker = &sync.Mutex{}

  

func isCallAllowed(allowedCount uint) bool {

Â  Â  if allowedCount == 0 {

Â  Â  Â  Â  return true

Â  Â  }

  

Â  Â  locker.Lock()

Â  Â  defer locker.Unlock()

  

Â  Â  curTimeIndex := uint(time.Now().Unix() / 30)

  

Â  Â  prevIndexVal, _ := callCount[curTimeIndex-1]

  

Â  Â  if prevIndexVal >= allowedCount {

Â  Â  Â  Â  return false

Â  Â  }

  

Â  Â  curIndexVal, ok := uint(0), false

Â  Â  if curIndexVal, ok = callCount[curTimeIndex]; !ok {

Â  Â  Â  Â  callCount[curTimeIndex] = 1

  

Â  Â  Â  Â  return true

Â  Â  }

  

Â  Â  if (curIndexVal + prevIndexVal) >= allowedCount {

Â  Â  Â  Â  return false

Â  Â  }

  

Â  Â  callCount[curTimeIndex]++

  

Â  Â  return true

}

  

func main() {

Â  Â  fmt.Printf("%v\n", isCallAllowed(3)) // true

Â  Â  fmt.Printf("%v\n", isCallAllowed(3)) // true

Â  Â  fmt.Printf("%v\n", isCallAllowed(3)) // true

  

Â  Â  // time.Sleep(time.Second*30)

  

Â  Â  fmt.Printf("%v\n", isCallAllowed(3)) // false

Â  Â  fmt.Printf("%v\n", isCallAllowed(3)) // false

  

}

```

  

---

  

### 16

  

ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ĞºĞ¾Ğ´, Ğ½Ğ°Ğ·Ğ²Ğ°Ñ‚ÑŒ, Ñ‡Ñ‚Ğ¾ Ğ²Ñ‹Ğ²ĞµĞ´ĞµÑ‚ÑÑ Ğ² stdout

ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ²ÑĞµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ² ĞºĞ¾Ğ´Ğµ Ğ¸ Ñ€ĞµÑˆĞ¸Ñ‚ÑŒ Ğ¸Ñ…

  

```go

package main

  

import (

Â  Â  "fmt"

Â  Â  "time"

)

  

type Agent struct {

Â  Â  ID Â  Â  Â int

Â  Â  Enabled bool

}

  

func (a Agent) Enable() {

Â  Â  a.Enabled = true

}

  

type Enabler interface {

Â  Â  Enable()

}

  

// 1. Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ»Ğ°Ğ¹ÑĞ° Ğ°Ğ³ĞµĞ½Ñ‚Ğ¾Ğ²

// 2. Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ ÑĞ»Ğ°Ğ¹ÑĞ° ÑÑ‚Ğ¾Ñ€Ğ¾Ğ½Ğ½Ğ¸Ğ¼Ğ¸ Ğ°Ğ³ĞµĞ½Ñ‚Ğ°Ğ¼Ğ¸

// 3. ĞŸĞ¾Ñ‚Ğ¾ĞºĞ¾Ğ²Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ² - Ğ°ĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ğ¸Ñ Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ½Ğ° Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹

// 4. ĞŸĞ¾Ñ‚Ğ¾ĞºĞ¾Ğ²Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ² - ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ² Ğ‘Ğ” Ğ¸ Ñ€Ğ°ÑĞ¿ĞµÑ‡Ğ°Ñ‚ĞºĞ° Ñ€ĞµĞ·ÑƒĞ»ÑŒĞ°Ñ‚Ğ¾Ğ²

func main() {

Â  Â  agents := make([]Agent, 0, 5)

Â  Â  for i := 0; i < 2; i++ {

Â  Â  Â  Â  agents = append(agents, Agent{ID: i})

Â  Â  }

  

Â  Â  addThirdPartyAgents(agents)

  

Â  Â  pipe := make(chan Enabler)

Â  Â  go pipeEnableAndSend(pipe, agents)

Â  Â  go pipeProcess(pipe)

}

  

func addThirdPartyAgents(agents []Agent) {

Â  Â  thirdParty := []Agent{

Â  Â  Â  Â  {ID: 4},

Â  Â  Â  Â  {ID: 5},

Â  Â  }

Â  Â  agents = append(agents, thirdParty...)

}

  

func pipeEnableAndSend(pipe chan Enabler, agents []Agent) {

Â  Â  for _, a := range agents {

Â  Â  Â  Â  a.Enable()

Â  Â  Â  Â  pipe <- a

Â  Â  }

}

  

func pipeProcess(pipe chan Enabler) {

Â  Â  for {

Â  Â  Â  Â  select {

Â  Â  Â  Â  case a := <-pipe:

Â  Â  Â  Â  Â  Â  dbWrite(a)

Â  Â  Â  Â  }

Â  Â  }

}

  

var dbWrite = func(a any) {

Â  Â  fmt.Println(a)

Â  Â  time.Sleep(time.Second * 1)

}

```

  

---

  

### 17

  

```go

package main

  

import (

Â  Â  "fmt"

Â  Â  "sync"

Â  Â  "time"

)

  

var cacheStore sync.Map

  

const timeout = time.Second

  

// GetData Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· getter, ÑÑ‚Ñ€Ğ°Ñ…ÑƒÑ ĞºĞµÑˆĞ¾Ğ¼

// Ğ² ÑĞ»ÑƒÑ‡Ğ°Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸. ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°: getter Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°Ñ‚ÑŒ Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ´Ğ¾Ğ»Ğ³Ğ¾.

// Ğ—Ğ°Ğ´Ğ°Ñ‡Ğ°: Ğ² ÑĞ»ÑƒÑ‡Ğ°Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° Ğ´Ğ¾Ğ»ÑŒÑˆĞµ timeout Ğ¾Ñ‚Ğ´Ğ°Ğ²Ğ°Ñ‚ÑŒ ĞºĞµÑˆ,

// Ğ¸ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ ĞºĞµĞ¹Ñ, ĞºĞ¾Ğ³Ğ´Ğ° getter Ğ²ÑĞµĞ³Ğ´Ğ° Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°ĞµÑ‚ Ğ´Ğ¾Ğ»Ğ³Ğ¾.

func GetData(key string, getter func() (interface{}, error)) (interface{}, error) {

Â  Â  data, err := getter()

Â  Â  if err == nil {

Â  Â  Â  Â  cacheStore.Store(key, data)

Â  Â  Â  Â  return data, nil

Â  Â  }

  

Â  Â  fmt.Printf("Getter result err: %s", err)

Â  Â  if data, ok := cacheStore.Load(key); ok {

Â  Â  Â  Â  return data, nil

Â  Â  }

  

Â  Â  return nil, err

}

```